import "hashes/sha256/1536bit.code" as sha256of1536
import "hashes/sha256/1024bit.code" as sha256of1024
import "hashes/sha256/512bit.code" as sha256of512
import "utils/pack/unpack128.code" as unpack128
import "utils/pack/nonStrictUnpack256.code" as unpack256
import "../common/el-gamal1.zok" as enc1
import "hashes/sha256/IVconstants.code" as IVconstants
import "hashes/sha256/shaRoundNoBoolCheck.code" as sha256
import "../common/order-fields.zok" as orderFields
import "../common/mimc-hash-2.zok" as mimc2
import "../common/edwards-compress.zok" as edwardsCompress
import "utils/pack/pack256.code" as pack256


def concatenate128x256x256(field[128] a, field[256] b, field[256] c)->(field[640]):
	return [...a, ...b, ...c]

def concatenate256x256(field[256] a, field[256] b)->(field[512]):
	return [...a, ...b]

def concatenate8xx256(field[256] a, field[256] b, field[256] c, field[256] d, field[256] e, field[256] f, field[256] g, field[256] h)->(field[2048]):
	return [...a, ...b, ...c, ...d, ...e, ...f, ...g, ...h]

def orderedConcatenate216x216(field order, field[216] pathNode, field[216] siblingNode)->(field[432]):
	field[216] left = if order == 0 then pathNode else siblingNode fi
	field[216] right = if order == 0 then siblingNode else pathNode fi
	return [...left, ...right]

def sha256of2560(field[256] a0, field[256] a1, field[256] a2, field[256] a3, field[256] a4, field[256] a5, field[256] a6, field[256] a7, field[256] a8, field[256] a9) -> (field[256]):
    IV =  IVconstants()
    digest1 =  sha256(a0, a1, IV)
    digest2 =  sha256(a2, a3, digest1)
    digest3 =  sha256(a4, a5, digest2)
    digest4 =  sha256(a6, a7, digest3)
    digest5 =  sha256(a8, a9, digest4)
  	return digest5

def shaPad432To512(field[432] a)->(field[512]):
	return [...a, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,1,0,1,1,0,0,0,0]

// Provides the padding (only!) for a 256-bit message.
def shaPad256To512()->(field[256]):
	return [1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0]

// Provides the padding (only!) for a 512-bit message.
def shaPad512To1024()->(field[512]):
	return [1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,  0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0]

// Provides the padding (only!) for a 640-bit message.
def shaPad640To1024()->(field[384]):
	return [1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	1,	0,	0,	0,	0,	0,	0,	0]

// Provides the padding (only!) for a 2816-bit message.
def shaPad2048To2560()->(field[512]):
	return [1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0]

// unpacks a siblingPath's node to bits, ready for sha-ing:
def unpackSiblingNode(field siblingNode)->(field[216]):
	field[256] siblingNodeBits = unpack256(siblingNode)
	return siblingNodeBits[40..256]

// unpack a field[2] (assumed to be two 128-bit values) into 256 bits
def unpack2xx128To256(field[2] input)->(field[256]):
	field[128] left = unpack128(input[0])
	field[128] right = unpack128(input[1])
  field[256] output = [...left, ...right]
  return output

// Inputs for main are:

// payTo, the public Ethereum address to which the burned tokens get paid
// value, the amount contained in the commitment (public)
// secretKey: the secret key for the commitment (private)
// salt: the salt for the commitment (private)
// path0b-path31b - the Merkle path for the commitment (private)

// nullifier - the nullifier for the commitment (public)

// root - the Merkle root (public)

// publicInputHash = hash(root, nullifier, value, payTo)

// Note - we now use 216 bits for the Merkle tree calculation. This is because 432 is the biggest input we can use for sha256 if we want 432/2 to end on a byte boundary for easier Solidity computation without needing to do full rounds and we need to concatenate the two child hashes. We consider 216 bits to be sufficiently secure. The nullifier, commitment and root retain 256-bit security.

// Each field element passed to main() can be at most 128bits, to make use of unpack128() so most variables occupy two fields (except the publicInputHash, which we maximize as 248-bits)

def main(field publicInputHash, private field[2] payTo, private field value, private field[2] secretKey, private field[2] salt, private field[32] path, private field order, private field[2] nullifier, private field[2] root, private field publicKeyRoot, private field[32] pathPublicKey, private field orderPublicKey, private field[4] encryption, private field[2] authorityPublicKey1, private field randomSecret)->():

	// Unpack the inputs of main() to 128 bits. We'll unpack each field to its own 128 bit string for simplicity for now. Later efficiencies could be made by grouping some inputs. We don't need to unpack payTo, because it isn't part of a hash.

	field[256] publicInputHashBits = unpack256(publicInputHash)

	field[256] payToBits = unpack2xx128To256(payTo)

	field[128] valueBits = unpack128(value)

	field[256] secretKeyBits = unpack2xx128To256(secretKey)

	field[256] saltBits = unpack2xx128To256(salt)

	field[128] orderBits = unpack128(order)

 	field[256] nullifierBits = unpack2xx128To256(nullifier)

 	field[256] rootBits = unpack2xx128To256(root)


	field[256] padding256To512 = shaPad256To512()
	field[512] padding512To1024 = shaPad512To1024()
	field[384] padding640To1024 = shaPad640To1024()
	field[512] padding2048To2560 = shaPad2048To2560()


 	// First we construct a proof that the nullifier is correct
 	// Concatenate salt|secretKey.

	field[512] preimage512 = concatenate256x256(saltBits, secretKeyBits)

	field[256] nullifierBitsCheck = sha256of1024(preimage512[0..256], preimage512[256..512], padding512To1024[0..256], padding512To1024[256..512])


	// Prove that the commitment is in the Merkle tree

	// First, calculate Alice's public key from her private key: publicKey = H(secretKey).

 	field[256] publicKeyBits = sha256of512(secretKeyBits, padding256To512)


 	// Next calculate the commitment = H(value|publicKey|salt)

	field[640] preimage640 = concatenate128x256x256(valueBits, publicKeyBits, saltBits)

	field[1024] preimage1024 = [...preimage640, ...padding640To1024]

	field[256] hash = sha256of1024(preimage1024[0..256], preimage1024[256..512], preimage1024[512..768], preimage1024[768..1024]) // commitment

	// concatenate siblings and hash all the way up to the root:
	for field i in 0..32 do
		field j = 31-i
		field k = 127-i
		preimage512 = shaPad432To512(orderedConcatenate216x216(orderBits[k], hash[40..256], unpackSiblingNode(path[j])))
		hash = sha256of512(preimage512[0..256], preimage512[256..512])
  endfor
	// save the computed root:
	field[256] rootBitsCheck = hash

	// And the encryption of the transaction (extend the value of the commitmentFBitsCheck up to 256 bits).
	// Note that, unlike transfer, we only have two variables to encrypt -the value and the sender's public key.
	field[4] w = enc1( publicKeyBits, authorityPublicKey1, randomSecret)
	// check the encryption has been computed correctly
	w == encryption

	// Now we need to prove that the zkp public key which we are using is whitelisted

	field publicKeyHash = pack256(publicKeyBits) // this converts the public key array into something that looks like a MiMC hash
	field[128] orderPublicKeyBits = unpack128(orderPublicKey)
	// concatenate siblings and hash all the way up to the root
	for field i in 0..32 do
		field j = 31-i
		field k = 127-i
		publicKeyHash = mimc2(orderFields(orderPublicKeyBits[k], publicKeyHash, pathPublicKey[j]))
	endfor
	publicKeyHash == publicKeyRoot // check that we have arrived at the root


	// Now test the remaining inputs
 	nullifierBits == nullifierBitsCheck
 	rootBits == rootBitsCheck


	// Check that the 'public inputs' hash to the publicInputHash:
	// (This also intertwines the 'payTo' input into the proof)
	// we have to expand the valueBits for this, because that's how Node and Solidity calculate it (due, ultimately, to the stack size limitations of Solidity)
	field[256] longValueBits = [...[0;128], ...valueBits]
	// To make the hash smaller, let's 'compress' each curve point ordered pair into a single 256 bit array (rather than two)...
	field[256] compressedEncryptionBits1 = edwardsCompress(encryption[0], encryption[1])
	field[256] compressedEncryptionBits2 = edwardsCompress(encryption[2], encryption[3])
	field[256] compressedAuthorityPublicKeyBits1 = edwardsCompress(authorityPublicKey1[0], authorityPublicKey1[1])

	field[2048] preimage2048 = concatenate8xx256(rootBits, nullifierBits, longValueBits, payToBits, unpack256(publicKeyRoot), compressedEncryptionBits1, compressedEncryptionBits2, compressedAuthorityPublicKeyBits1)

	field[2560] preimage2560 = [...preimage2048, ...padding2048To2560]

	field[256] publicInputHashBitsCheck = sha256of2560(preimage2560[0..256], preimage2560[256..512], preimage2560[512..768], preimage2560[768..1024], preimage2560[1024..1280], preimage2560[1280..1536], preimage2560[1536..1792], preimage2560[1792..2048], preimage2560[2048..2304], preimage2560[2304..2560])

	publicInputHashBits[8..256] == publicInputHashBitsCheck[8..256]


 	return
